# BiliTraceC 问题诊断与修复技术文档

本文档详细记录了在开发历史弹幕溯源功能时遇到的核心技术问题、根本原因分析及最终解决方案。

## 1. 核心竞态条件 (Race Condition)

### 现象

在历史模式下，工具高频率返回错误的 UID（如 `4244699697`），该 UID 的 Hash 与目标 Hash 根本不匹配。

### 根本原因

多线程破解模块 `cracker.c` 存在严重的线程安全缺陷：

1. **全局状态污染**：使用全局变量 `g_result_uid` 和 `g_found` 存储结果，且未加锁。
2. **时序问题**：当多个线程几乎同时检测到碰撞（CRC32 碰撞概率极低但存在，且错误计算可能导致虚假命中），或者在连续调用 `crack_hash` 时，上一轮未完全退出的线程可能会覆写当前轮次的结果。
3. **原子性缺失**：对 `uint64_t` 的读写在某些平台上非原子操作，导致读取到损坏的数据。

### 修复方案

**架构升级：线程安全的多线程设计**

- 重新实现多线程破解器，采用以下策略：
  1. **线程本地化结果**：使用 `ThreadContext` 结构体，每个线程仅写入自己的上下文，无共享写入。
  2. **原子早停信号**：使用 `<stdatomic.h>` 的 `atomic_int` 作为全局停止信号，首个找到结果的线程通知其他线程停止。
  3. **主线程归约**：所有线程 join 后，主线程遍历上下文数组，取最小命中 UID。
  
- **性能**：Intel Ultra 9 (24线程) 约 3 秒完成 0-50亿 全空间扫描，相比单线程提速 3 倍以上。

---

## 2. Protobuf 数据截断导致 Hash 错误

### 现象

工具对部分历史弹幕报错 "Hash 格式异常 (Len: 7)"，且无法破解出正确 UID。

### 根本原因

B站 Protobuf 接口的数据压缩策略：

- **前导零省略**：当 Hash 值的十六进制表示以 `0` 开头时（例如 `087c8c3d`），Protobuf 序列化会将其存储为 `87c8c3d`（7 字节String）。
- **解析错误**：工具直接使用 `strtoul` 解析 `87c8c3d`，导致实际搜索的 Hash 变为 `0x0087c8c3d`，而真正的 Hash 是 `0x087c8c3d`。

### 修复方案

**Hash 规范化 (Normalization)**

- 在 `main.c` 中增加预处理逻辑：检测 Hash 长度。
- 如果长度小于 8 位，自动在左侧补 `0` 至 8 位（`87c8c3d` -> `087c8c3d`），确保输入给破解器的 Hash 值与标准 CRC32 输出对齐。

---

## 3. "不存在用户" 的误判

### 现象

正确破解出的 UID（如 `1040801720`）在 B 站查询显示 "-404 啥都木有"，导致误以为破解失败。

### 根本原因

- **幸存者偏差**：用户习惯于验证存在的账号。
- **事实真相**：经过全空间（0-50亿）穷举扫描，确认该 UID 是目标 Hash 的**唯一数学解**。
- **账号状态**：该 UID 对应的账号已被**注销**或**封禁**。工具忠实还原了历史数据的“尸体”，而非计算错误。

### 结论

工具是正确的。当遇到 404 用户时，说明该弹幕是已注销用户发送的历史遗留数据。
